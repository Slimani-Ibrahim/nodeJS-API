const jwt = require("jsonwebtoken");
const httpStatus = require("http-status");
const {success_code, success_message, unauthorized_message, error_code} = require("../helpers");


const generateJwtAccess = (req, res) => {
    const user = req.body;
    //the signing of jwt token in this approach is based on symetric encryption, once shared key for both encode and decode
    //the secret key is generated by crypto lib : require('crypto').randomBytes(64).toString('hex')
    jwt.sign({user}, process.env.SECRET_KEY, {algorithm:"HS512", expiresIn: 2592000}, (err, token) =>  {
        if(!err){
            res.status(httpStatus.OK)
                .json({code:success_code, message:success_message, token:"Bearer "+token});
        }
    });

    jwt.sign({"salam":"salam"}, process.env.SECRET_KEY, (err, token) => {
        console.log("Bearer "+token);
    })
}


ensureToken = function (req, res, next ) {
    var BearerHeader = req.headers["authorization"];
    if(typeof BearerHeader !== 'undefined'){
        const bearer = BearerHeader.split(" ");
        const bearerToken = bearer[1];
        jwt.verify(bearerToken, process.env.SECRET_KEY, (err, result)=>{
            if(err){
                console.log("err : "+err);
                res.status(httpStatus.UNAUTHORIZED)
                    .json({code:error_code, message:unauthorized_message});
            }else{
                console.log("jwt ensured : "+result);
                next();
            }
        })
    }else{
        res.status(httpStatus.UNAUTHORIZED)
            .json({code:error_code, message: unauthorized_message});
    }
}

module.exports = {
    generateJwtAccess, ensureToken
}
